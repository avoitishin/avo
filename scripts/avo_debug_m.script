--[[-- INFO -------------------------------------------------------------------
	File				: avo_debug_m
	Description : Debug functions and callbacks for most game events
	Credits		 	: aVo
	Revision		: 0.4
	Change Date : 07.26.2013
--]]---------------------------------------------------------------------------
--[[-- TODO -------------------------------------------------------------------
	1. luacap debug functionality
--]]---------------------------------------------------------------------------
--/----------------------------------------------------------------------------
--/ Variables
--/----------------------------------------------------------------------------
local empty = function(...) end --/ plug
local sname = script_name()

local show_top_hud = false
local show_left_hud = false
local show_right_hud = false
local keybind_shift_key = DIK_keys.DIK_RCONTROL
local keybind_toggle_top_hud = DIK_keys.DIK_HOME
local keybind_toggle_left_hud = DIK_keys.DIK_DELETE
local keybind_toggle_right_hud = DIK_keys.DIK_END
local debug_hud_top = nil
local debug_hud_left = nil
local debug_hud_right = nil

local toggle_top_key = 1
local toggle_left_key = 1
local toggle_right_key = 2
local top_debug_huds = {"position_hud", "corpse_hud"}
local left_debug_huds = {"position_hud", "corpse_hud"}
local right_debug_huds = {"position_hud", "corpse_hud"}

--/----------------------------------------------------------------------------
--/ Module entry point.
--/----------------------------------------------------------------------------
function _init(ini)
	_G.callstack = this.callstack
	_G.abort = this.abort

	--/ Logging
	local printf_log = avo_utils.read_from_ini(ini,"logging","printf","bool",false)
	local debug_log = avo_utils.read_from_ini(ini,"logging","debug","bool",false)
	local warning_log = avo_utils.read_from_ini(ini,"logging","warning","bool",false)
	local error_log = avo_utils.read_from_ini(ini,"logging","error","bool",false)
	local visual_log = avo_utils.read_from_ini(ini,"logging","visual","bool",false)
	if debug_log then _G.dlog = avo_log.dlog else _G.dlog = empty end
	if warning_log then _G.wlog = avo_log.wlog else _G.wlog = empty end
	if error_log then _G.elog = avo_log.elog else _G.elog = empty end
	if visual_log then _G.vlog = avo_log.vlog else _G.vlog = empty end
	if printf_log then _G.printf = avo_log.printf else _G.printf = empty end
	
	--/ Debug
	local dev_debug = avo_utils.read_from_ini(ini,"debug","dev_debug","bool",false)
	local sim_debug = avo_utils.read_from_ini(ini,"debug","sim_debug","bool",false)
	if dev_debug then _G.dev_debug = true end
	if sim_debug then _G.sim_debug = true end
	
	--/ Debug HUD
	show_top_hud = avo_utils.read_from_ini(ini,"debug_hud","show_top_hud","bool",false)
	show_left_hud = avo_utils.read_from_ini(ini,"debug_hud","show_left_hud","bool",false)
	show_right_hud = avo_utils.read_from_ini(ini,"debug_hud","show_right_hud","bool",false)
	keybind_shift_key = DIK_keys["DIK_"..avo_utils.read_from_ini(ini,"debug_hud","keybind_shift_key","string","RCONTROL")]
	keybind_toggle_top_hud = DIK_keys["DIK_"..avo_utils.read_from_ini(ini,"debug_hud","keybind_toggle_top_hud","string","HOME")]
	keybind_toggle_left_hud = DIK_keys["DIK_"..avo_utils.read_from_ini(ini,"debug_hud","keybind_toggle_left_hud","string","DELETE")]
	keybind_toggle_right_hud = DIK_keys["DIK_"..avo_utils.read_from_ini(ini,"debug_hud","keybind_toggle_right_hud","string","END")]
	
	--/ Callbacks
	if avo_utils.read_from_ini(ini,"callbacks","enabled","bool",false) then init_slots() end
end

--/----------------------------------------------------------------------------
--/ Debug HUDs
--/----------------------------------------------------------------------------
function position_hud_show(hud)
	local pos = db.actor:position()
	local cam
	if (pos:distance_to_sqr(device().cam_pos) > 25) then
		cam = true
		pos = device().cam_pos
	end

	local lvid = cam and level.vertex_id(pos) or db.actor:level_vertex_id()
	local gvid = cam and nil or db.actor:game_vertex_id()

	local dir = device().cam_dir
	local pos2 = level.vertex_position(lvid)
	local valid = pos2:distance_to(pos) <= 0.7

	local se_actor = not cam and alife():object(db.actor:id())

	hud:set_header("-[Position Info]-")
	hud:add_msg("Lvid",lvid)
	hud:add_msg("Gvid",gvid)
	hud:add_msg("Pos",string.format("%0.4f, %0.4f, %0.4f", pos.x, pos.y, pos.z))
	hud:add_msg("Dir",string.format("%0.3f, %0.3f, %0.3f HP = %0.3f, %0.3f", dir.x, dir.y, dir.z,dir:getH(),dir:getP()))
	hud:add_msg("Angle",se_actor and se_actor.angle and string.format("%0.3f, %0.3f, %0.3f", se_actor.angle.x, se_actor.angle.y, se_actor.angle.z))
	hud:add_msg("Valid",valid)
	hud:add_msg("FOV",math.floor(device().fov))

	local Y, M, D, h, m, s, ms
	Y, M, D, h, m, s, ms = game.get_game_time():get( Y, M, D, h, m, s, ms )
	hud:add_msg("GameTime",string.format("Y:%d M:%d D:%d h:%d m:%d s:%d ms:%d",Y, M, D, h, m, s, ms))
	hud:display()
end

function corpse_hud_show(hud)
	local corpses = release_body_manager.get_release_body_manager().release_objects_table
	local id, obj
	hud:set_header("-[Dead People]-")
	hud:add_msg("Count",#corpses)
	for i=1,#corpses do
		id = corpses[i].id
		obj = id and level.object_by_id(id)
		if (obj) then
			hud:add_msg("",obj:name().."  DeathTime = "..obj:death_time())
		end
	end
	
	hud:display()
end

--/----------------------------------------------------------------------------
--/ Build call stack trace 
--/----------------------------------------------------------------------------
function callstack()
	local	t = {}
	if debug then
		t = avo_string.split(debug.traceback(), '\n', true)
		for k,v in pairs(t) do
			if string.match(v, "stack traceback") then 
				next(t)
			else
				t[k] = string.format("[%d] %s", k-1, string.gsub(string.gsub(v, ".+\\", ""), ">", ""))
			end
		end
	end
	return t
end

--/----------------------------------------------------------------------------
--/ Abort game and log error details
--/----------------------------------------------------------------------------
function abort(msg, ...)
	avo_log.log("[ABORT] "..avo_log.dbg_format(msg, ...))
	avo_log.log(table.concat(callstack(), '\n'))
  avo_log.flush()
  local fail = avo_abort_game/0
end

--/----------------------------------------------------------------------------
--/ Callback subscribers
--/----------------------------------------------------------------------------
function init_slots()
	--/ avo_controller
  slot("avo_game_start", on_avo_game_start)
	--/ bind_stalker
  slot("actor_init", on_actor_init)
  slot("actor_net_spawn", on_actor_net_spawn)
  slot("actor_net_destroy", on_actor_net_destroy)
  slot("actor_reinit", on_actor_reinit)
  slot("actor_update", on_actor_update)
  slot("actor_save", on_actor_save)
  slot("actor_load", on_actor_load)
	
	slot("actor_take_item_from_box", on_actor_take_item_from_box)
	slot("actor_info_callback", on_actor_info_callback)
	slot("actor_on_trade", on_actor_on_trade)
	slot("actor_article_callback", on_actor_article_callback)
	slot("actor_on_item_take", on_actor_on_item_take)
	slot("actor_on_item_drop", on_actor_on_item_drop)
	slot("actor_use_inventory_item", on_actor_use_inventory_item)
	slot("actor_anabiotic_callback", on_actor_anabiotic_callback)
	slot("actor_anabiotic_callback2", on_actor_anabiotic_callback2)
	slot("actor_task_callback", on_actor_task_callback)
	
	slot("actor_hit_callback", on_actor_hit_callback)
	slot("actor_on_key", on_actor_on_key)
end

--/----------------------------------------------------------------------------
--/ Callbacks
--/----------------------------------------------------------------------------
function on_avo_game_start()
  dlog("AVO GAME STARTED")
end

function on_actor_init(actor_binder)
	dlog("actor_binder.__init(obj) called")
end

function on_actor_net_spawn(data)
	dlog("actor_binder.net_spawn(data) called")
	
	--/ Setup debug huds
	if show_top_hud then debug_hud_top = hud_tool("debug_hud_top") end
	if show_left_hud then debug_hud_left = hud_tool("debug_hud_left") end
	if show_right_hud then debug_hud_right = hud_tool("debug_hud_right") end
	
end

function on_actor_net_destroy()
	dlog("actor_binder.net_destroy() called")
end

function on_actor_reinit()
	dlog("actor_binder.reinit() called")
end

function on_actor_update(delta)
	-- dlog("actor_binder.update(delta) called")
	
	--/ Update debug hud displays
	if show_top_hud then
		_G["avo_debug_m"][top_debug_huds[toggle_top_key].."_show"](debug_hud_top)
	end
	if show_right_hud then
		_G["avo_debug_m"][right_debug_huds[toggle_right_key].."_show"](debug_hud_right)
	end
	if show_left_hud then
		_G["avo_debug_m"][left_debug_huds[toggle_left_key].."_show"](debug_hud_left)
	end
end

function on_actor_save(packet)
	dlog("actor_binder.save(packet) called")
end

function on_actor_load(reader)
	dlog("actor_binder.load(reader) called")
end

function actor_take_item_from_box(box, item)
	dlog("actor_binder.take_item_from_box(box, item) called")
end

function on_actor_info_callback(npc, info_id)
	dlog("actor_binder.info_callback(npc, info_id) called")
end

function on_actor_on_trade(item, sell_bye, money)
	dlog("actor_binder.on_trade(item, sell_bye, money) called")
end

function on_actor_article_callback(npc, group, name)
	dlog("actor_binder.article_callback(npc, group, name) called")
end

function on_actor_on_item_take(obj)
	dlog("actor_binder.on_item_take(obj) called")
end

function on_actor_on_item_drop(obj)
	dlog("actor_binder.on_item_drop(obj) called")
end

function on_actor_use_inventory_item(obj)
	dlog("actor_binder.use_inventory_item(obj) called")
end

function on_actor_anabiotic_callback()
	dlog("actor_binder.anabiotic_callback() called")
end

function on_actor_anabiotic_callback2()
	dlog("actor_binder.anabiotic_callback2() called")
end

function on_actor_task_callback(_task, _state)
	dlog("actor_binder.task_callback(_task, _state) called")
end

function on_actor_hit_callback(obj, amount, local_direction, who, bone_index)
	dlog("actor_binder.hit_callback(obj, amount, local_direction, who, bone_index) called")
end

local prev_key = nil
function on_actor_on_key(key)
	--/ Toggle debug hud displays
	if key == keybind_toggle_top_hud and prev_key == keybind_shift_key then
		if toggle_top_key < #top_debug_huds then
			toggle_top_key = toggle_top_key + 1
		else
			toggle_top_key = 1
		end
	elseif key == keybind_toggle_left_hud and prev_key == keybind_shift_key then
		if toggle_left_key < #left_debug_huds then
			toggle_left_key = toggle_left_key + 1
		else
			toggle_left_key = 1
		end
	elseif key == keybind_toggle_right_hud and prev_key == keybind_shift_key then
		if toggle_right_key < #right_debug_huds then
			toggle_right_key = toggle_right_key + 1
		else
			toggle_right_key = 1
		end
	end
	prev_key = key
end


--/----------------------------------------------------------------------------
--/ Class to create hud tools
--/----------------------------------------------------------------------------
class "hud_tool"
function hud_tool:__init(custom_static)
	local hud = get_hud()
	self.hud = hud:GetCustomStatic(custom_static)
	if not (self.hud) then
		hud:AddCustomStatic(custom_static, true)
		self.hud = hud:GetCustomStatic(custom_static)
	end
	self.header = ""
	self.msg = ""
end

function hud_tool:add_msg(text,value)
	self.msg = self.msg..avo_string.str_format(text..": %s\\n",value)
end

function hud_tool:set_header(header)
	self.header = header
end

function hud_tool:display(disable)
	if (self.hud) and not (disable) then
		self.hud:wnd():TextControl():SetText(self.msg)
		self.msg = self.header and self.header .."\\n" or ""
	end
end

function hud_tool:clear()
	if (self.hud) then
		self.hud:wnd():TextControl():SetText("")
	end
end
