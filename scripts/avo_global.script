--[[-- INFO -------------------------------------------------------------------
	File				: avo_global
	Description	: Global functions
	Credits			: aVo
	Revision		: 1.0
	Change Date	: 08.05.2013
--]] --------------------------------------------------------------------------
--/----------------------------------------------------------------------------
--/ Variables
--/----------------------------------------------------------------------------
local cfg_file = "avo\\avo_global.ltx"
local self_name = script_name()

--/----------------------------------------------------------------------------
--/ Initialization
--/ Note: some global constants and flags are registered in avo_netpk
--/----------------------------------------------------------------------------
function _init()
	local start = os.clock() -- benchmark
	local ini = ini_file(cfg_file)
	
	local lua_debug_on = read_ini(ini,"debug","lua_debug","bool",false)
	if lua_debug_on then require('RvP') end -- turn on lua debug (requires bin\RvP.dll)

	_G["abort"] = this.abort	-- crash game
	_G["ASSERT"] = this.ASSERT -- game specific assert
	_G["fn_empty"] = this.fn_empty -- empty function
	_G["collect_garbage"] = this.collect_garbage -- collect garbage
	
	db.avo = {} -- initialize framework space (will hold storage, online objects, etc)
	
	_G["ext_namespace"] = this.ext_namespace -- protection against overriding lua functions
	
	avo_lua._init() --/ initialize lua extensions
	
	_G["read_ini"] = this.read_ini	-- read value from config file
	_G["read_ini_section"] = this.read_ini_section	-- read section from config file
	
	local dlog_on = read_ini(ini,"logging","debug","bool",false)
	local elog_on = read_ini(ini,"logging","error","bool",false)
	local wlog_on = read_ini(ini,"logging","warning","bool",false)
	local vlog_on = read_ini(ini,"logging","visual","bool",false)
	local printf_on = read_ini(ini,"logging","printf","bool",false)
	
	if dlog_on then _G["dlog"] = avo_log.dlog else _G["dlog"] = this.fn_empty end
	if elog_on then _G["elog"] = avo_log.elog else _G["elog"] = this.fn_empty end
	if wlog_on then _G["wlog"] = avo_log.wlog else _G["wlog"] = this.fn_empty end
	if vlog_on then _G["vlog"] = avo_log.vlog else _G["vlog"] = this.fn_empty end
	if printf_on then _G["printf"] = avo_log.printf else _G["printf"] = this.fn_empty end
	
	ini = nil -- help gc
	
	this.init_signals() -- initialize signals manager
	
	avo_netpk._init() -- initialize netpacket manager
	_G["get_netpk"] = avo_netpk.get
	
	avo_storage._init()	-- initialize storage (db.avo) manager 
	_G["save_astor"] = avo_storage.set
	_G["load_astor"] = avo_storage.get
	
	--/ initialize timers here
	
	-- this.init_callbacks() -- initialize custom (xray extensions) callbacks
	
	avo_game_utils._init()	-- initialize game utilities
	_G["agu"] = avo_game_utils -- alias
	_G["save_pstor"] = xr_logic.pstor_store
	_G["load_pstor"] = xr_logic.pstor_retrieve
	
	avo_controller._init() --/ initialize controller as last step
	
	avo_log.log(string.format("----| AVO FRAMEWORK LOADED (in %.3f seconds) |----", os.clock() - start))
	
	avo_log.log(collect_garbage())
end

--/----------------------------------------------------------------------------
--/ initialize callbacks
--/----------------------------------------------------------------------------
-- function init_callbacks()
	-- slot("actor_set_callbacks", this.set_actor_callbacks)
	-- slot("actor_remove_callbacks", this.remove_actor_callbacks)
-- end
-- function set_actor_callbacks(actor_binder)
	-- actor_binder.object:set_callback(callback.hit, this.on_actor_hit, actor_binder)
	-- actor_binder.object:set_callback(123, this.on_key_press, actor_binder) -- key press
-- end
-- function remove_actor_callbacks(actor_binder)
	-- actor_binder.object:set_callback(callback.hit, nil)
	-- actor_binder.object:set_callback(123, nil) -- key press
-- end
-- function on_actor_hit(obj, amount, local_direction, who, bone_index)
	-- sm:call("actor_hit", obj, amount, local_direction, who, bone_index)
-- end
-- function on_key_press(key)
	-- dlog("key pressed: %s", key)
	-- sm:call("actor_key_press", key)
-- end

--/----------------------------------------------------------------------------
--/ initialize signals manager
--/----------------------------------------------------------------------------
function init_signals()
  local sm = avo_signals.get_mgr()
  if sm then _G["sm"] = sm else abort("(%s) falied to initialize signals manager", self_name) end
  _G["slot"] = avo_signals.slot
end

--/----------------------------------------------------------------------------
--/ global functions
--/----------------------------------------------------------------------------
--/ protection for extending existing lua namespaces with new functions
--/ (i.e. string.split etc)
function ext_namespace(ns, name, fn)
	if type(ns) ~= 'string' or type(name) ~= 'string' or type(fn) ~= 'function' then 
		abort("Invalid parameter types passed to ext_namespace(string,string,function): %s, %s, %s", type(ns),type(name), type(fn)) 
	end
	if _G[ns][name] then 
		abort("Function [%s] is already registered in [%s]", name, ns)
	else
		_G[ns][name] = fn
	end
end
--/ abort game and log error details
function abort(msg,...)
	local function log(msg, ...)
		if log1 then
			log1("[ABORT] "..string.format(msg, ...))
		else
			get_console():execute("load ~:[ABORT] "..string.format(msg, ...))
		end
	end
	local function flush()
		if flush1 then
			flush1()
		else
			get_console():execute('flush')
		end
	end
	local function callstack()
		local	dbg_stack = avo_lua.split(debug.traceback(), '\n', true) -- dependent on avo_lua
		table.remove(dbg_stack, 2) -- remove callstack
		table.remove(dbg_stack, 2) -- remove abort
		for k,v in pairs(dbg_stack) do
			if string.match(v, "stack traceback") then next(dbg_stack)
			else dbg_stack[k] = string.format("[%d] %s", k-1, string.gsub(string.gsub(v, ".+\\", ""), ">", ""))
			end
		end
		return dbg_stack
	end
	log(msg, ...)
	if debug then log(table.concat(callstack(), '\n')) end
  flush()
	os.exit(666)
  -- local fail = avo_abort_game/0
end
--/ game specific assert. will crash game if cond is false
function ASSERT(cond, msg)
	if not cond then
    abort(msg)
  end
end
--/ collect garbage and return statistics
function collect_garbage()
	local before = collectgarbage('count')/1024
	collectgarbage()
	local after = collectgarbage('count')/1024
	return string.format("**[GC] mem before %.2fM | mem after %.2fM] | mem freed %.2fM", before, after, before-after)
end

--/----------------------------------------------------------------------------
--/ config file utilities
--/----------------------------------------------------------------------------
--/ read value from config file
function read_ini(ini,section,line,var_type,default)
	if not (ini) then
		ini = system_ini()
	end
	if (section and line and ini:section_exist(section) and ini:line_exist(section,line)) then
		if (var_type == "bool") then
			return ini:r_bool(section,line)
		elseif (var_type == "string") then
			return ini:r_string(section,line)
		elseif (var_type == "float") then
			return ini:r_float(section,line)
		else
			return ini:r_string_wq(section,line)
		end
	else
		return default
	end
end
--/ read section from config file
function read_ini_section(ini,section)
	local tmp = nil
	local trim = string.trim
	if ini and ini:section_exist(section) then
		tmp = {}
		local result, id, value = nil, nil, nil
		for a = 0, ini:line_count(section) - 1 do
			result, id, value = ini:r_line(section,a,'','')
			if id ~= nil and trim(id) ~= '' then
				tmp[trim(id)] = trim(value)
			end
		end
	end
	return tmp
end


--/ empty function used as plug
function fn_empty(...)
end